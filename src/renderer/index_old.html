<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Electron</title>
    <script src="/libs/live2dcubismcore.min.js"></script>
    <script src="/libs/live2d.min.js"></script>
  </head>

  <body>
    <div id="root"></div>
    <audio id="player" controls autoplay style="display:none;"></audio>
    <audio id="voice" hidden></audio>
    <script type="module" src="/src/main.tsx"></script>
    <script>
      // const mockData = {
      //   play_url: "https://8a7d-219-70-65-54.ngrok-free.app/music/sing_opt/vocal.mp3",
      //   play_background_url: "https://8a7d-219-70-65-54.ngrok-free.app/music/sing_opt/instrument.mp3"
      // };

      // // æ¨¡æ“¬ WebSocket æ”¶åˆ°è¨Šæ¯
      // (async () => {
      //   const player = document.getElementById("player");

      //   const base64Promise = fetchMp3AsBase64(mockData.play_url);
      //   const bgAudioPromise = new Promise(resolve => {
      //     player.src = mockData.play_background_url;
      //     player.oncanplaythrough = () => resolve();
      //   });

      //   const [base64] = await Promise.all([base64Promise, bgAudioPromise]);

      //   if (base64) {
      //     player.play();
      //     const voice = document.getElementById("voice");
      //     voice.src = `data:audio/wav;base64,${base64}`;
      //     voice.crossOrigin = "anonymous";
      //     await voice.play();
      //     startMouthAnimation(window.live2dModel, voice);
      //   }
      // })();

      // fetchMp3AsBase64("https://apiboxfiles.erweima.ai/YWY0NGJhZWItNWJhMC00OWJhLWE1MGQtYmE4MTdjMDdmZDMx.mp3").then(base64 => {
      //       if (base64) {
      //         console.log('Base64:', base64);
      //         // å¦‚æœè¦åŠ ä¸Š data URI å‰ç¶´ï¼Œå¯é€™æ¨£ç”¨ï¼š
      //         // console.log('data:audio/wav;base64,' + base64);
      //         window.live2dModel.speak(`data:audio/wav;base64,${base64}`);
      //       }
      //     });
      const ws = new WebSocket("wss://8a7d-219-70-65-54.ngrok-free.app/ws_music");
      ws.onopen = () => console.log("âœ… WebSocket å·²é€£ç·š");
      ws.onmessage = async (event) => {
        const data = JSON.parse(event.data);
        if (!data.play_url || !data.play_background_url) return;

        console.log("ğŸ”” æ”¶åˆ°æ’­æ”¾é€šçŸ¥ï¼š", data.play_url);

        const player = document.getElementById("player");
        const voice = document.getElementById("voice");

        try {
          // è¼‰å…¥èƒŒæ™¯éŸ³è¨Š
          const bgReady = new Promise((resolve) => {
            player.src = data.play_background_url;
            player.oncanplaythrough = () => resolve();
          });

          // ä¸‹è¼‰äººè²éŸ³æª”ä¸¦è½‰ base64
          const base64Voice = await fetchMp3AsBase64(data.play_url);
          if (!base64Voice) throw new Error("ğŸš« äººè² MP3 ä¸‹è¼‰å¤±æ•—");

          // è¨­å®šäººè²ä¾†æº
          voice.src = `data:audio/wav;base64,${base64Voice}`;
          voice.crossOrigin = "anonymous";

          // ç¢ºä¿èƒŒæ™¯éŸ³èˆ‡äººè²éƒ½ ready
          await Promise.all([bgReady, voice.play()]);

          // æ’­æ”¾èƒŒæ™¯èˆ‡å•Ÿå‹•å‹•ç•«
          player.play();
          startMouthAnimation(window.live2dModel, voice);

        } catch (err) {
          console.error("âš ï¸ æ’­æ”¾å¤±æ•—ï¼š", err);
        }
      };
      
      ws.onopen = () => console.log("âœ… WebSocket å·²é€£ç·š");
      ws.onclose = () => console.log("âŒ WebSocket é—œé–‰");

      // async function fetchMp3AsBase64(mp3Url) {
      //     try {
      //       const response = await fetch(mp3Url);
      //       if (!response.ok) {
      //         throw new Error(`HTTP error! status: ${response.status}`);
      //       }

      //       const blob = await response.blob();

      //       return await new Promise((resolve, reject) => {
      //         const reader = new FileReader();
      //         reader.onloadend = () => {
      //           const base64data = reader.result.split(',')[1]; // å»æ‰ data:audio/wav;base64, å‰ç¶´
      //           resolve(base64data);
      //         };
      //         reader.onerror = reject;
      //         reader.readAsDataURL(blob);
      //       });
      //     } catch (error) {
      //       console.error('Error fetching or converting MP3:', error);
      //       return null;
      //     }
      //   }
      // const mp3Url = "https://8a7d-219-70-65-54.ngrok-free.app/music/sing_opt/vocal.mp3";
      // playVoiceWithMouthSync(window.live2dModel, mp3Url);
        // ä¸‹è¼‰ MP3 ä¸¦è½‰ base64

        function getRandomBlinkDelay() {
          return 3 + Math.random() * 3; // æ¯ 3~6 ç§’çœ¨ä¸€æ¬¡çœ¼
        }

        function updateBlink(time) {
          const elapsed = time - lastBlinkTime;

          if (!isBlinking && elapsed >= nextBlinkDelay) {
            // é–‹å§‹çœ¨çœ¼
            isBlinking = true;
            blinkProgress = 0;
          }

          if (isBlinking) {
            blinkProgress += 0.1; // èª¿æ•´é€™å€‹å€¼æ§åˆ¶çœ¨çœ¼é€Ÿåº¦
            const blinkValue = Math.sin(Math.PI * blinkProgress); // 0~1~0 éç¨‹

            model.setParamFloat("PARAM_EYE_L_OPEN", 1 - blinkValue);
            model.setParamFloat("PARAM_EYE_R_OPEN", 1 - blinkValue);

            if (blinkProgress >= 1) {
              // å®Œæˆçœ¨çœ¼
              isBlinking = false;
              lastBlinkTime = time;
              nextBlinkDelay = getRandomBlinkDelay();
            }
          }
        }

        async function fetchMp3AsBase64(url) {
          const response = await fetch(url,
            {
              headers: {
                "ngrok-skip-browser-warning": "69420"
              }
            }
          );
          const blob = await response.blob();

          return await new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => {
              const base64 = reader.result.split(',')[1]; // å»æ‰ data:audio/wav;base64,...
              resolve(base64);
            };
            reader.onerror = reject;
            reader.readAsDataURL(blob);
          });
        }

        // å˜´å‹å‹•ç•«æ§åˆ¶å™¨
        function startMouthAnimation(live2dModel, audio) {
          const model = live2dModel.internalModel?.coreModel;
          const paramId = "PARAM_MOUTH_OPEN_Y";

          if (!model || typeof model.setParamFloat !== 'function') {
            console.error("ğŸš« æ‰¾ä¸åˆ°æ­£ç¢ºçš„ Live2D core model ä¾†æ§åˆ¶å˜´å‹");
            return;
          }

          const audioContext = new AudioContext();
          const source = audioContext.createMediaElementSource(audio);
          const analyser = audioContext.createAnalyser();
          analyser.fftSize = 512;

          source.connect(analyser);
          analyser.connect(audioContext.destination);

          const dataArray = new Uint8Array(analyser.frequencyBinCount);

          let stopped = false;
          let smoothedVolume = 0;
          let displayedVolume = 0; // ğŸ‘‰ é¡¯ç¤ºçµ¦å˜´å·´çš„å€¼
          const smoothing = 0.6;
          const decayRate = 0.02; // å˜´å·´é—œé–‰æ™‚çš„ä¸‹é™é€Ÿåº¦

          let silentFrameCount = 0;
          const maxSilentFrames = 30; // å¹¾å¹€å¾Œé–‹å§‹é—œå˜´

          const tick = () => {
            if (audio.paused || audio.ended) {
              if (!stopped) {
                displayedVolume = Math.max(0, displayedVolume - decayRate); // æ…¢æ…¢æ”¶å˜´
                model.setParamFloat(paramId, displayedVolume);
                model.update();
                live2dModel.update();

                if (displayedVolume > 0) {
                  requestAnimationFrame(tick);
                  return;
                }

                console.log("âœ… å˜´å‹å‹•ç•«çµæŸ");
                stopped = true;
              }
              return;
            }

            analyser.getByteFrequencyData(dataArray);
            const slice = dataArray.slice(0, dataArray.length / 3);
            const avg = slice.reduce((sum, val) => sum + val, 0) / slice.length;

            let volume = Math.min(avg / 196, 1);
            smoothedVolume = smoothing * smoothedVolume + (1 - smoothing) * volume;

            if (smoothedVolume < 0.02) {
              silentFrameCount++;
            } else {
              silentFrameCount = 0;
            }

            if (silentFrameCount >= maxSilentFrames) {
              displayedVolume = Math.max(0, displayedVolume - decayRate); // å¹³æ»‘ä¸‹é™
            } else {
              displayedVolume = smoothedVolume;
            }
            model.setParamFloat(paramId, Math.max(displayedVolume, 0.03));
            const time = performance.now() / 1000;
            // const swingBase = Math.max(smoothedVolume, 0.05);
            // const swingStrength = swingBase * 15;  // å‹•ä½œæ“´å¤§ä¿‚æ•¸ï¼Œå¯èª¿å¤§ä¸€é»
            const swingStrength = 10;
            // é ­éƒ¨å·¦å³æ–æ“ºï¼ˆå¹³æ»‘ï¼‰
            model.setParamFloat("PARAM_ANGLE_X", Math.sin(time * 1.5) * swingStrength);

            // é ­éƒ¨ä¸Šä¸‹å¾®å‹•ï¼ˆåƒé»é ­ï¼‰
            model.setParamFloat("PARAM_ANGLE_Y", Math.sin(time * 0.8 + 1) * swingStrength * 0.5);

            // èº«é«”å·¦å³å¾®æ“ºï¼ˆè·Ÿè‘—éŸ³é‡ï¼‰
            model.setParamFloat("PARAM_BODY_X", Math.cos(time * 0.2) * swingStrength * 0.4);

            // å˜´å‹è®ŠåŒ–ï¼ˆå˜´è§’å½åº¦ï¼Œå¯è¡¨æƒ…æ›´è±å¯Œï¼‰
            model.setParamFloat("PARAM_MOUTH_FORM", Math.sin(time * 1.5) * 0.3);

            // çœ¨çœ¼æ§åˆ¶ï¼ˆä½¿ç”¨ sin æ³¢å½¢æ¨¡æ“¬è‡ªç„¶çœ¨çœ¼ï¼‰
            let lastBlinkTime = 0;
            let nextBlinkDelay = getRandomBlinkDelay();
            let blinkProgress = 0;
            let isBlinking = false;

            function getRandomBlinkDelay() {
              return 3 + Math.random() * 3; // æ¯ 3~6 ç§’çœ¨ä¸€æ¬¡çœ¼
            }

            function updateBlink(time) {
              const elapsed = time - lastBlinkTime;

              if (!isBlinking && elapsed >= nextBlinkDelay) {
                // é–‹å§‹çœ¨çœ¼
                isBlinking = true;
                blinkProgress = 0;
              }

              if (isBlinking) {
                blinkProgress += 0.1; // èª¿æ•´é€™å€‹å€¼æ§åˆ¶çœ¨çœ¼é€Ÿåº¦
                const blinkValue = Math.sin(Math.PI * blinkProgress); // 0~1~0 éç¨‹

                model.setParamFloat("PARAM_EYE_L_OPEN", 1 - blinkValue);
                model.setParamFloat("PARAM_EYE_R_OPEN", 1 - blinkValue);

                if (blinkProgress >= 1) {
                  // å®Œæˆçœ¨çœ¼
                  isBlinking = false;
                  lastBlinkTime = time;
                  nextBlinkDelay = getRandomBlinkDelay();
                }
              }
            }
            
            // å¯é¸ï¼šçœ¼çƒè¼•å¾®å·¦å³æ¼‚ç§»ï¼ˆé¿å…æ­»é­šçœ¼ï¼‰
            const eyeBallX = Math.sin(time * 0.3) * 0.1;
            model.setParamFloat("PARAM_EYE_BALL_X", eyeBallX);
            
            updateBlink(time);
            model.update();
            live2dModel.update();

            requestAnimationFrame(tick);
          };

          audioContext.resume().then(() => {
            tick(); // ğŸŸ¢ å•Ÿå‹•å˜´å‹å‹•ç•«
          });

          audio.onended = () => {
            stopped = true;
            model.setParamFloat(paramId, 0);
            model.update();
            console.log("âœ… å˜´å‹å‹•ç•«çµæŸ");
          };
        }
        
        async function playVoiceWithMouthSync(live2dModel, mp3Url) {
          const base64 = await fetchMp3AsBase64(mp3Url);
          const audio = document.getElementById("voice");
          audio.src = `data:audio/wav;base64,${base64}`;
          audio.crossOrigin = "anonymous";
          await audio.play();
          startMouthAnimation(live2dModel, audio);
        }

    </script>
  </body>
</html>