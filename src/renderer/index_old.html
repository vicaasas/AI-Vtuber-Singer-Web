<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Electron</title>
    <script src="/libs/live2dcubismcore.min.js"></script>
    <script src="/libs/live2d.min.js"></script>
  </head>

  <body>
    <div id="root"></div>
    <audio id="player" controls autoplay style="display:none;"></audio>
    <audio id="voice" hidden></audio>
    <script type="module" src="/src/main.tsx"></script>
    <script>
      // const mockData = {
      //   play_url: "https://8a7d-219-70-65-54.ngrok-free.app/music/sing_opt/vocal.mp3",
      //   play_background_url: "https://8a7d-219-70-65-54.ngrok-free.app/music/sing_opt/instrument.mp3"
      // };

      // // 模擬 WebSocket 收到訊息
      // (async () => {
      //   const player = document.getElementById("player");

      //   const base64Promise = fetchMp3AsBase64(mockData.play_url);
      //   const bgAudioPromise = new Promise(resolve => {
      //     player.src = mockData.play_background_url;
      //     player.oncanplaythrough = () => resolve();
      //   });

      //   const [base64] = await Promise.all([base64Promise, bgAudioPromise]);

      //   if (base64) {
      //     player.play();
      //     const voice = document.getElementById("voice");
      //     voice.src = `data:audio/wav;base64,${base64}`;
      //     voice.crossOrigin = "anonymous";
      //     await voice.play();
      //     startMouthAnimation(window.live2dModel, voice);
      //   }
      // })();

      // fetchMp3AsBase64("https://apiboxfiles.erweima.ai/YWY0NGJhZWItNWJhMC00OWJhLWE1MGQtYmE4MTdjMDdmZDMx.mp3").then(base64 => {
      //       if (base64) {
      //         console.log('Base64:', base64);
      //         // 如果要加上 data URI 前綴，可這樣用：
      //         // console.log('data:audio/wav;base64,' + base64);
      //         window.live2dModel.speak(`data:audio/wav;base64,${base64}`);
      //       }
      //     });
      const ws = new WebSocket("wss://8a7d-219-70-65-54.ngrok-free.app/ws_music");
      ws.onopen = () => console.log("✅ WebSocket 已連線");
      ws.onmessage = async (event) => {
        const data = JSON.parse(event.data);
        if (!data.play_url || !data.play_background_url) return;

        console.log("🔔 收到播放通知：", data.play_url);

        const player = document.getElementById("player");
        const voice = document.getElementById("voice");

        try {
          // 載入背景音訊
          const bgReady = new Promise((resolve) => {
            player.src = data.play_background_url;
            player.oncanplaythrough = () => resolve();
          });

          // 下載人聲音檔並轉 base64
          const base64Voice = await fetchMp3AsBase64(data.play_url);
          if (!base64Voice) throw new Error("🚫 人聲 MP3 下載失敗");

          // 設定人聲來源
          voice.src = `data:audio/wav;base64,${base64Voice}`;
          voice.crossOrigin = "anonymous";

          // 確保背景音與人聲都 ready
          await Promise.all([bgReady, voice.play()]);

          // 播放背景與啟動動畫
          player.play();
          startMouthAnimation(window.live2dModel, voice);

        } catch (err) {
          console.error("⚠️ 播放失敗：", err);
        }
      };
      
      ws.onopen = () => console.log("✅ WebSocket 已連線");
      ws.onclose = () => console.log("❌ WebSocket 關閉");

      // async function fetchMp3AsBase64(mp3Url) {
      //     try {
      //       const response = await fetch(mp3Url);
      //       if (!response.ok) {
      //         throw new Error(`HTTP error! status: ${response.status}`);
      //       }

      //       const blob = await response.blob();

      //       return await new Promise((resolve, reject) => {
      //         const reader = new FileReader();
      //         reader.onloadend = () => {
      //           const base64data = reader.result.split(',')[1]; // 去掉 data:audio/wav;base64, 前綴
      //           resolve(base64data);
      //         };
      //         reader.onerror = reject;
      //         reader.readAsDataURL(blob);
      //       });
      //     } catch (error) {
      //       console.error('Error fetching or converting MP3:', error);
      //       return null;
      //     }
      //   }
      // const mp3Url = "https://8a7d-219-70-65-54.ngrok-free.app/music/sing_opt/vocal.mp3";
      // playVoiceWithMouthSync(window.live2dModel, mp3Url);
        // 下載 MP3 並轉 base64

        function getRandomBlinkDelay() {
          return 3 + Math.random() * 3; // 每 3~6 秒眨一次眼
        }

        function updateBlink(time) {
          const elapsed = time - lastBlinkTime;

          if (!isBlinking && elapsed >= nextBlinkDelay) {
            // 開始眨眼
            isBlinking = true;
            blinkProgress = 0;
          }

          if (isBlinking) {
            blinkProgress += 0.1; // 調整這個值控制眨眼速度
            const blinkValue = Math.sin(Math.PI * blinkProgress); // 0~1~0 過程

            model.setParamFloat("PARAM_EYE_L_OPEN", 1 - blinkValue);
            model.setParamFloat("PARAM_EYE_R_OPEN", 1 - blinkValue);

            if (blinkProgress >= 1) {
              // 完成眨眼
              isBlinking = false;
              lastBlinkTime = time;
              nextBlinkDelay = getRandomBlinkDelay();
            }
          }
        }

        async function fetchMp3AsBase64(url) {
          const response = await fetch(url,
            {
              headers: {
                "ngrok-skip-browser-warning": "69420"
              }
            }
          );
          const blob = await response.blob();

          return await new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => {
              const base64 = reader.result.split(',')[1]; // 去掉 data:audio/wav;base64,...
              resolve(base64);
            };
            reader.onerror = reject;
            reader.readAsDataURL(blob);
          });
        }

        // 嘴型動畫控制器
        function startMouthAnimation(live2dModel, audio) {
          const model = live2dModel.internalModel?.coreModel;
          const paramId = "PARAM_MOUTH_OPEN_Y";

          if (!model || typeof model.setParamFloat !== 'function') {
            console.error("🚫 找不到正確的 Live2D core model 來控制嘴型");
            return;
          }

          const audioContext = new AudioContext();
          const source = audioContext.createMediaElementSource(audio);
          const analyser = audioContext.createAnalyser();
          analyser.fftSize = 512;

          source.connect(analyser);
          analyser.connect(audioContext.destination);

          const dataArray = new Uint8Array(analyser.frequencyBinCount);

          let stopped = false;
          let smoothedVolume = 0;
          let displayedVolume = 0; // 👉 顯示給嘴巴的值
          const smoothing = 0.6;
          const decayRate = 0.02; // 嘴巴關閉時的下降速度

          let silentFrameCount = 0;
          const maxSilentFrames = 30; // 幾幀後開始關嘴

          const tick = () => {
            if (audio.paused || audio.ended) {
              if (!stopped) {
                displayedVolume = Math.max(0, displayedVolume - decayRate); // 慢慢收嘴
                model.setParamFloat(paramId, displayedVolume);
                model.update();
                live2dModel.update();

                if (displayedVolume > 0) {
                  requestAnimationFrame(tick);
                  return;
                }

                console.log("✅ 嘴型動畫結束");
                stopped = true;
              }
              return;
            }

            analyser.getByteFrequencyData(dataArray);
            const slice = dataArray.slice(0, dataArray.length / 3);
            const avg = slice.reduce((sum, val) => sum + val, 0) / slice.length;

            let volume = Math.min(avg / 196, 1);
            smoothedVolume = smoothing * smoothedVolume + (1 - smoothing) * volume;

            if (smoothedVolume < 0.02) {
              silentFrameCount++;
            } else {
              silentFrameCount = 0;
            }

            if (silentFrameCount >= maxSilentFrames) {
              displayedVolume = Math.max(0, displayedVolume - decayRate); // 平滑下降
            } else {
              displayedVolume = smoothedVolume;
            }
            model.setParamFloat(paramId, Math.max(displayedVolume, 0.03));
            const time = performance.now() / 1000;
            // const swingBase = Math.max(smoothedVolume, 0.05);
            // const swingStrength = swingBase * 15;  // 動作擴大係數，可調大一點
            const swingStrength = 10;
            // 頭部左右搖擺（平滑）
            model.setParamFloat("PARAM_ANGLE_X", Math.sin(time * 1.5) * swingStrength);

            // 頭部上下微動（像點頭）
            model.setParamFloat("PARAM_ANGLE_Y", Math.sin(time * 0.8 + 1) * swingStrength * 0.5);

            // 身體左右微擺（跟著音量）
            model.setParamFloat("PARAM_BODY_X", Math.cos(time * 0.2) * swingStrength * 0.4);

            // 嘴型變化（嘴角彎度，可表情更豐富）
            model.setParamFloat("PARAM_MOUTH_FORM", Math.sin(time * 1.5) * 0.3);

            // 眨眼控制（使用 sin 波形模擬自然眨眼）
            let lastBlinkTime = 0;
            let nextBlinkDelay = getRandomBlinkDelay();
            let blinkProgress = 0;
            let isBlinking = false;

            function getRandomBlinkDelay() {
              return 3 + Math.random() * 3; // 每 3~6 秒眨一次眼
            }

            function updateBlink(time) {
              const elapsed = time - lastBlinkTime;

              if (!isBlinking && elapsed >= nextBlinkDelay) {
                // 開始眨眼
                isBlinking = true;
                blinkProgress = 0;
              }

              if (isBlinking) {
                blinkProgress += 0.1; // 調整這個值控制眨眼速度
                const blinkValue = Math.sin(Math.PI * blinkProgress); // 0~1~0 過程

                model.setParamFloat("PARAM_EYE_L_OPEN", 1 - blinkValue);
                model.setParamFloat("PARAM_EYE_R_OPEN", 1 - blinkValue);

                if (blinkProgress >= 1) {
                  // 完成眨眼
                  isBlinking = false;
                  lastBlinkTime = time;
                  nextBlinkDelay = getRandomBlinkDelay();
                }
              }
            }
            
            // 可選：眼球輕微左右漂移（避免死魚眼）
            const eyeBallX = Math.sin(time * 0.3) * 0.1;
            model.setParamFloat("PARAM_EYE_BALL_X", eyeBallX);
            
            updateBlink(time);
            model.update();
            live2dModel.update();

            requestAnimationFrame(tick);
          };

          audioContext.resume().then(() => {
            tick(); // 🟢 啟動嘴型動畫
          });

          audio.onended = () => {
            stopped = true;
            model.setParamFloat(paramId, 0);
            model.update();
            console.log("✅ 嘴型動畫結束");
          };
        }
        
        async function playVoiceWithMouthSync(live2dModel, mp3Url) {
          const base64 = await fetchMp3AsBase64(mp3Url);
          const audio = document.getElementById("voice");
          audio.src = `data:audio/wav;base64,${base64}`;
          audio.crossOrigin = "anonymous";
          await audio.play();
          startMouthAnimation(live2dModel, audio);
        }

    </script>
  </body>
</html>